코틀린

- 모듈로 프로그램 설계
    - 모듈: 클래스, 객체, 함수, 타입 별청(type alias), 톱 레벨 프로퍼티 등으로 구성
        - 일부는 상태를 가질 수 있음 ⇒ 해당 요소의 동작은 사용 방법과 이력(history)에 의존
            
            ```kotlin
            // var: 읽고 쓸 수 있는 프로퍼티
            // mutable 객체
            
            var a = 10
            var list: MutableList<Int> = mutableListOf()
            ```
            
            ```kotlin
            class BankAccount {
            	var balance = 0.0
            		private set
            
            	fun deposit(depositAmount: Double) {
            		balance += depositAmount
            	}
            
            	@Throws(InsufficientFunds::class)
            	fun withdraw(withdrawAmount: Double) {
            		if (balance < withdrawAmount) {
            			throw InsufficientFunds()
            		}
            		balance -= withdrawAmount
            	}
            }
            
            class InsufficientFunds: Exception()
            val account = BankAccount()
            println(account.balance) // 0.0
            ```
            
            - BankAccount → 상태 존재(계좌에 돈이 얼만큼 있는지)

**상태를 갖는다는 것**

- 장점) 시간의 변화에 따라 변하는 요소 표현 가능
- 단점) 상태를 적절하게 관리하는 것이 어려움
    1. 프로그램을 이해하고 디버그하기 어려움
    2. 멀티스레드 프로그램일 때 적절한 동기화 필요

**일관성, 복잡성 문제**

```kotlin
var num = 0
for (i in 1..1000) {
	thread {
		Thread.sleep(10)
		num += 1
	}
}
Thread.sleep(5000)
print(num) // 1000이 아닐 확률 높음
// 실행 시마다 다른 숫자 나옴
```

```kotlin
// 코루틴 사용 시: 더 적은 스레드가 관여되어 충돌 문제가 줄어들긴 하지만 문제가 사라지지는 않음

suspend fun main() {
	var num = 0
	coroutineScope {
		for(i in 1..1000) {
			launch {
				delay(10)
				num += 1
			}
		}
	}
	print(num) // 실행할 때마다 다른 숫자
}
```

- 일부 연산 충돌 → 동기화 구현 필수

```kotlin
val lock = Any()
var num = 0
for (i in 1..1000) {
	thread {
		Thread.sleep(10)
		synchronized(lock) {
			num += 1
		}
	}
}
Thread.sleep(1000)
print(num) // 1000
```

